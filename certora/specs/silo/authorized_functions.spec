
/**
@title Authorized function:
list and verify functions that can be executed only by other silo contracts 
*/

import "../summaries/two_silos_summaries.spec";
import "../summaries/siloconfig_dispatchers.spec";
import "../summaries/config_for_two_in_cvl.spec";
import "../summaries/tokens_dispatchers.spec";
import "../summaries/safe-approximations.spec";
import "../requirements/tokens_requirements.spec";


using SiloConfig as siloConfig_AF;
using Silo0 as silo0_AF;
using Silo1 as silo1_AF;

// To keep the contract aliases unique, we added the suffix `_AF` (for `Authorized Functions`)
using ShareDebtToken0 as shareDebtToken0_AF;
using ShareProtectedCollateralToken0 as shareProtectedCollateralToken0_AF;
using ShareDebtToken1 as shareDebtToken1_AF;
using ShareProtectedCollateralToken1 as shareProtectedCollateralToken1_AF;
using EmptyHookReceiver as hookReceiver_AF;

// libraries also have addresses, and delegate-call (generated by the compiler to these addresses) are safe calls 
using SiloLendingLib as siloLendingLib;
using ShareTokenLib as shareTokenLib;
using Actions as actionsLib;

// list of functions that are invoked only by another silo contract 
definition onlySiloContractsMethods(method f) returns bool =
    ( (f.contract == shareDebtToken0_AF || f.contract == shareDebtToken1_AF ||
        (f.contract == shareProtectedCollateralToken0_AF || f.contract == shareProtectedCollateralToken1_AF) ||
        f.contract == silo0_AF || f.contract == silo1_AF) &&
        (   f.selector == sig:shareDebtToken0_AF.synchronizeHooks(uint24,uint24).selector ||
            f.selector == sig:shareDebtToken0_AF.burn(address,address,uint256).selector ||
            f.selector == sig:shareDebtToken0_AF.forwardTransferFromNoChecks(address,address,uint256).selector ||
            f.selector == sig:shareDebtToken0_AF.mint(address,address,uint256).selector 
        )
    )
    ||
    (  f.contract ==  siloConfig_AF &&
        (   f.selector == sig:onDebtTransfer(address,address).selector ||
            f.selector == sig:turnOnReentrancyProtection().selector ||
            f.selector == sig:turnOffReentrancyProtection().selector ||
            f.selector == sig:setOtherSiloAsCollateralSilo(address).selector ||
            f.selector == sig:setThisSiloAsCollateralSilo(address).selector
        )
     )
     ;



// list of silo-contracts and libraries 
definition siloContracts(address c) returns bool = 
        c == silo0_AF || c == silo1_AF ||
        c == shareDebtToken0_AF || c == shareProtectedCollateralToken0_AF ||
        c == shareDebtToken1_AF || c == shareProtectedCollateralToken1_AF ||
        c == hookReceiver_AF ||
        c == siloConfig_AF._INTEREST_RATE_MODEL0 ||
        c == siloConfig_AF._INTEREST_RATE_MODEL1 ||
        c == siloLendingLib ||
        c == actionsLib ||
        c == shareTokenLib ; 

/** @title check the list of onlySiloContractsMethods that indeed the msg.sender is always a silo contracts.
    @dev checked with hooks on load operation to the reentrant guard and on external calls  */ 
rule onlyTrustedSender(method f) filtered { f -> onlySiloContractsMethods(f) } {
    env e;
    configForEightTokensSetupRequirements();
    nonSceneAddressRequirements(e.msg.sender);
    silosTimestampSetupRequirements(e);
    calldataarg args;
    f@withrevert(e,args);
    assert !lastReverted => (siloContracts(e.msg.sender));
}


/* check the setup */ 
// known issue with decimal which is ok as we summarize it 
rule check_sanity(method f) filtered { f -> !onlySiloContractsMethods(f) && f.selector != sig:ShareDebtToken0.decimals().selector } 
{
    // setup requirements 
    env e;
    configForEightTokensSetupRequirements();
    nonSceneAddressRequirements(e.msg.sender);
    silosTimestampSetupRequirements(e);

    calldataarg args;
    f(e,args);
    satisfy true;
}

/* check the setup */ 
rule check_sanity_authorizedFunctions(method f) filtered { f -> onlySiloContractsMethods(f) }
{
    // setup requirements 
    env e;
    configForEightTokensSetupRequirements();
    silosTimestampSetupRequirements(e);

    calldataarg args;
    f(e,args);
    satisfy true;
}