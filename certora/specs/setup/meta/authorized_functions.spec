
/**
@title Authorized functions:
list and verify functions that can be executed only by other silo contracts 
*/

import "../CompleteSiloSetup.spec";
using EmptyHookReceiver as hookReceiver;

// libraries also have addresses, and delegate-call (generated by the compiler to these addresses) are safe calls 
using SiloLendingLib as siloLendingLib;
using ShareTokenLib as shareTokenLib;
using Actions as actionsLib;

// list of functions that are invoked only by another silo contract 
definition onlySiloContractsMethods(method f) returns bool =
    ( (f.contract == shareDebtToken0 || f.contract == shareDebtToken1 ||
        (f.contract == shareProtectedCollateralToken0 || f.contract == shareProtectedCollateralToken1) ||
        f.contract == silo0 || f.contract == silo1) &&
        (   f.selector == sig:ShareDebtToken0.synchronizeHooks(uint24,uint24).selector ||
            f.selector == sig:ShareDebtToken0.burn(address,address,uint256).selector ||
            f.selector == sig:ShareDebtToken0.forwardTransferFromNoChecks(address,address,uint256).selector ||
            f.selector == sig:ShareDebtToken0.mint(address,address,uint256).selector ||
            f.selector == sig:Silo0.accrueInterestForConfig(address,uint256,uint256).selector

        )
    )
    ||
    (  f.contract ==  siloConfig &&
        (   f.selector == sig:SiloConfig.onDebtTransfer(address,address).selector ||
            f.selector == sig:SiloConfig.turnOnReentrancyProtection().selector ||
            f.selector == sig:SiloConfig.turnOffReentrancyProtection().selector ||
            f.selector == sig:SiloConfig.setOtherSiloAsCollateralSilo(address).selector ||
            f.selector == sig:SiloConfig.setThisSiloAsCollateralSilo(address).selector
        )
     )
     ;



// list of silo-contracts and libraries 
definition siloContracts(address c) returns bool = 
        c == silo0 || c == silo1 ||
        c == shareDebtToken0 || c == shareProtectedCollateralToken0 ||
        c == shareDebtToken1 || c == shareProtectedCollateralToken1 ||
        c == hookReceiver ||
        c == siloConfig._INTEREST_RATE_MODEL0 ||
        c == siloConfig._INTEREST_RATE_MODEL1 ||
        c == siloLendingLib ||
        c == actionsLib ||
        c == shareTokenLib ; 

/** @title check the list of onlySiloContractsMethods that indeed the msg.sender is always a silo contracts.
    @dev checked with hooks on load operation to the reentrant guard and on external calls  */ 
rule onlyTrustedSender(method f) filtered { f -> onlySiloContractsMethods(f) } {
    env e;
    configForEightTokensSetupRequirements();
    nonSceneAddressRequirements(e.msg.sender);
    silosTimestampSetupRequirements(e);
    calldataarg args;
    f@withrevert(e,args);
    assert !lastReverted => (siloContracts(e.msg.sender));
}


/* check the setup */ 
// known issue with decimal which is ok as we summarize it 
rule check_sanity(method f) filtered { f -> !onlySiloContractsMethods(f) && f.selector != sig:ShareDebtToken0.decimals().selector } 
{
    // setup requirements 
    env e;
    configForEightTokensSetupRequirements();
    nonSceneAddressRequirements(e.msg.sender);
    silosTimestampSetupRequirements(e);

    calldataarg args;
    f(e,args);
    satisfy true;
}

/* check the setup */ 
rule check_sanity_authorizedFunctions(method f) filtered { f -> onlySiloContractsMethods(f) }
{
    // setup requirements 
    env e;
    configForEightTokensSetupRequirements();
    silosTimestampSetupRequirements(e);

    calldataarg args;
    f(e,args);
    satisfy true;
}