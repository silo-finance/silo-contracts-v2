## Unit-test
1. deposit(uint256 _assets, address _receiver) 
- deposit must increase in total assets of the system && increase of total shares
- reciever recieve shares, others stays the same (including msg.sender)
- msg.sender gives underlying asset underlying.balanceOf(msg.sender) decrease 
- deposit(x, to ); deposit(y,to) at init;   x < y => sharesX <= sharesY 
- additivity: deposit(x); deposit(y)  ~  deposit(x+y) , one does not gain by splitting 
- without interest deposit(x, to ) x == shareX  
- reverts on zero-worth deposit, user must get shares otherwise revert 
- revert if has a debt 
- frontRunning:
-- deposit(e, x, to); compare to f(e,args);deposit(e, x,to)
2. mint
- mint(uint256 shares, address _receiver)  should be equivelent to deposit( shresToAssets(shares), _reciever) by comparing state after 

## valid-state
- assets >= shares 
- shares > 0 <=> assets > 0 

## varaible transition
- increase in total assets of the system <=> increase of total shares with exception of interst 
## high-level 
- sum of balances 
- underlying.balaceOf(silo) >= totalAssets() - sumOfDebt 

## state transition
a user in debt mode, cannot recieve collateral shares 

## risk assesment
- no effect from external transfer 
f() ; 
uint256 option1 = totalAssets():
compare to:
underlying.transfer(e,silo,xx)
f() ;  
assert option1 == totalAssets():
the state of silo is the same + view functions are the same 

- non working oracle does not lock silo 
mock price that reverts, satisfy rule 

- solvency check : any change to the debt balance there should be a solvency check after 